## 一、rpc和grpc

### rpc 面临的问题

**远程过程调⽤(Remote Procedure Call)带来的新问题**

在远程调⽤时，我们需要执⾏的函数体是在远程的机器上的，也就是说，add 是在另⼀个进程中执⾏的。这就带来了⼏个新问题：

1. **Call ID 映射**。我们怎么告诉远程机器我们要调⽤ add，⽽不是 sub 或者 Foo 呢？在本地调⽤中，函数体是直接通过函数指针来指定的，我们调⽤ add，编译器就⾃动帮我们调⽤它相应的函数指针。但是在远程调⽤中，函数指针是不⾏的，因为两个进程的地址空间是完全不⼀样的。所以，在 RPC 中，所有的函数都必须有⾃⼰的⼀个 ID。这个 ID 在所有进程中都是唯⼀确定的。客户端在做远程过程调⽤时，必须附上这个 ID。然后我们还需要在客户端和服务端分别维护⼀个 {函数 <–> Call ID} 的对应表。两者的表不⼀定需要完全相同，但相同的函数对应的 Call ID 必须相同。当客户端需要进⾏远程调⽤时，它就查⼀下这个表，找出相应的 Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调⽤的函数，然后执⾏相应函数的代码。
2. **序列化和反序列化**。客户端怎么把参数值传给远程的函数呢？在本地调⽤中，我们只需要把参数压到栈⾥，然后让函数⾃⼰去栈⾥读就⾏。但是在远程过程调⽤时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚⾄有时候客户端和服务端使⽤的都不是同⼀种语⾔（⽐如服务端⽤ C++，客户端⽤ Java 或者 Python）。这时候就需要客户端把参数先转成⼀个字节流，传给服务端后，再把字节流转成⾃⼰能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。
3. **⽹络传输**。远程调⽤往往⽤在⽹络上，客户端和服务端是通过⽹络连接的。所有的数据都需要通过⽹络传输，因此就需要有⼀个⽹络传输层。⽹络传输层需要把 Call ID 和序列化后的参数字节流传给服务端，然后再把序列化后的调⽤结果传回客户端。只要能完成这两者的，都可以作为传输层使⽤。因此，它所使⽤的协议其实是不限的，能完成传输就⾏。尽管⼤部分 RPC 框架都使⽤ TCP 协议，但其实 UDP 也可以，⽽ gRPC ⼲脆就⽤了 HTTP2。Java 的 Netty 也属于这层的东⻄。

